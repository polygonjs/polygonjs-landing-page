<template>
	<section>
		<p>
			<span class="block bg-black relative aspect-w-2 aspect-h-1">
				<span class="h-full">
					<PolygonjsScene
						:loadFunction="loadFunction"
						:sceneName="'scene_03'"
						@sceneready="onSceneReady"
					></PolygonjsScene>
				</span>
			</span>
			<span class="text-sm flex lg:space-x-1">
				<span @click="toggleTopHoles" :class="['cursor-pointer border-b-4', toggleTopHolesClassObjects]">{{
					toggleTopHolesLabel
				}}</span>
				<span class="hidden lg:inline text-sm">&bull;</span>
				<span @click="toggleSideHoles" :class="['cursor-pointer border-b-4', toggleSideHolesClassObjects]">{{
					toggleSideHolesLabel
				}}</span>
				<span class="hidden lg:inline text-sm">&bull;</span>
				<span @click="toggleSideFilet" :class="['cursor-pointer border-b-4', toggleSideFilletClassObjects]">{{
					toggleSideFilletLabel
				}}</span>
				<span class="hidden lg:inline text-sm">&bull;</span>
				<span
					@click="switchDisplayMode"
					:class="['cursor-pointer border-b-4', switchDisplayModeClassObjects]"
					>{{ displayModeLabel }}</span
				>
				<span v-show="cookingInProgress">
					<ArrowPathIcon class="animate-spin inline pointer-events-none w-4 h-4"></ArrowPathIcon>
				</span>
			</span>
		</p>
	</section>
</template>

<script lang="ts">
import {defineComponent, ref, computed, nextTick} from 'vue';
import {PolygonjsScene} from '@polygonjs/vue3';
import {loadScene_scene_03} from './scene_03/autogenerated/loadScene';
import type {PolySceneWithNodeMap_scene_03} from './scene_03/autogenerated/PolySceneWithNodeMap';
import {ArrowPathIcon} from '@heroicons/vue/24/outline';

enum DisplayMode {
	ALL = 'Mesh + Edges',
	MESH_ONLY = 'Mesh Only',
	EDGES_ONLY = 'Edges Only',
}
const DISPLAY_MODES: DisplayMode[] = [DisplayMode.ALL, DisplayMode.MESH_ONLY, DisplayMode.EDGES_ONLY];

export default defineComponent({
	name: 'scene-03',
	components: {
		PolygonjsScene,
		ArrowPathIcon,
	},
	setup() {
		let scene: PolySceneWithNodeMap_scene_03 | undefined;

		function onSceneReady(loadedScene: PolySceneWithNodeMap_scene_03) {
			scene = loadedScene;
			_listenToCook();
		}
		const loadFunction = computed(() => loadScene_scene_03);

		const topHolesPresent = ref(true);
		const sideHolesPresent = ref(true);
		const sideFilletPresent = ref(true);
		const displayModeIndex = ref(0);
		const cookingInProgress = ref(true);

		//
		//
		// labels
		//
		//
		const toggleTopHolesLabel = computed(() =>
			topHolesPresent.value ? 'remove decorative holes' : 'add decorative holes'
		);
		const toggleSideHolesLabel = computed(() =>
			sideHolesPresent.value ? 'remove ventilation holes' : 'add ventilation holes'
		);
		const toggleSideFilletLabel = computed(() =>
			sideFilletPresent.value ? 'remove side fillet' : 'add side fillet'
		);
		const displayModeLabel = computed(() => {
			let nextDisplayIndex: number = displayModeIndex.value + 1;
			if (nextDisplayIndex >= DISPLAY_MODES.length) {
				nextDisplayIndex = 0;
			}
			return 'display ' + DISPLAY_MODES[nextDisplayIndex];
		});

		//
		//
		// classes
		//
		//
		const toggleTopHolesClassObjects = computed(() =>
			topHolesPresent.value ? 'border-red-800' : 'border-green-800'
		);
		const toggleSideHolesClassObjects = computed(() =>
			sideHolesPresent.value ? 'border-red-800' : 'border-green-800'
		);
		const toggleSideFilletClassObjects = computed(() =>
			sideFilletPresent.value ? 'border-red-800' : 'border-green-800'
		);
		const switchDisplayModeClassObjects = computed(() => {
			const displayMode = DISPLAY_MODES[displayModeIndex.value];
			switch (displayMode) {
				case DisplayMode.ALL:
					return 'border-fuchsia-800';
					break;
				case DisplayMode.MESH_ONLY:
					return 'border-yellow-800';
					break;
				case DisplayMode.EDGES_ONLY:
					return 'border-blue-800';
					break;
			}
		});

		//
		//
		// callbacks
		//
		//
		function _withLoader(callback: () => void) {
			setTimeout(callback, 50);
			cookingInProgress.value = true;
		}
		function toggleTopHoles() {
			if (!scene) {
				return;
			}
			const param = scene.node('/geo1/switch_top_holes').p.input;
			_withLoader(() => {
				param.set(param.value == 0 ? 1 : 0);
				topHolesPresent.value = param.value == 1;
			});
		}
		function toggleSideHoles() {
			if (!scene) {
				return;
			}
			const param = scene.node('/geo1/switch_side_holes').p.input;
			_withLoader(() => {
				param.set(param.value == 0 ? 1 : 0);
				sideHolesPresent.value = param.value == 1;
			});
		}
		function toggleSideFilet() {
			if (!scene) {
				return;
			}
			const param = scene.node('/geo1/switch_side_fillet').p.input;
			_withLoader(() => {
				param.set(param.value == 0 ? 1 : 0);
				sideFilletPresent.value = param.value == 1;
			});
		}
		function switchDisplayMode() {
			if (!scene) {
				return;
			}
			displayModeIndex.value++;
			if (displayModeIndex.value >= DISPLAY_MODES.length) {
				displayModeIndex.value = 0;
			}
			const displayMode = DISPLAY_MODES[displayModeIndex.value];
			const node = scene.node('/geo1/CADTriangulate1');
			_withLoader(() => {
				if (!scene) {
					return;
				}
				scene.batchUpdates(() => {
					switch (displayMode) {
						case DisplayMode.ALL:
							node.p.displayEdges.set(true);
							node.p.displayMeshes.set(true);
							break;
						case DisplayMode.MESH_ONLY:
							node.p.displayEdges.set(false);
							node.p.displayMeshes.set(true);
							break;
						case DisplayMode.EDGES_ONLY:
							node.p.displayEdges.set(true);
							node.p.displayMeshes.set(false);
							break;
					}
				});
			});
		}

		//
		//
		// display cook loader
		//
		//
		function _listenToCook() {
			if (!scene) {
				return;
			}
			cookingInProgress.value = false;
			const node = scene.node('/geo1/material1');
			node.cookController.registerOnCookEnd('display_cook_loader', () => {
				cookingInProgress.value = false;
			});
		}

		return {
			loadFunction,
			onSceneReady,
			//
			toggleTopHoles,
			toggleTopHolesLabel,
			toggleTopHolesClassObjects,
			//
			toggleSideHoles,
			toggleSideHolesLabel,
			toggleSideHolesClassObjects,
			//
			toggleSideFilet,
			toggleSideFilletLabel,
			toggleSideFilletClassObjects,
			//
			switchDisplayMode,
			displayModeLabel,
			switchDisplayModeClassObjects,
			//
			cookingInProgress,
		};
	},
});
</script>

<style></style>
